package euler.problems;

public class Problem012 implements IProblem {

	public int getID() {
		return 12;
	}

	public String getDescription() {
		return "The sequence of triangle numbers is generated by adding " + 
		"the natural numbers. So the 7th triangle number would be " + 
		"1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:\n\n" +
		
		"1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...\n\n" +
		
		"Let us list the factors of the first seven triangle numbers:\n\n" +
		
		"      1: 1\n" +
		"      3: 1,3\n" +
		"      6: 1,2,3,6\n" +
		"     10: 1,2,5,10\n" +
		"     15: 1,3,5,15\n" +
		"     21: 1,3,7,21\n" +
		"     28: 1,2,4,7,14,28\n\n" +
		
		"We can see that 28 is the first triangle number to have over five divisors.\n\n" +
		
		"What is the value of the first triangle number to have over five hundred divisors?";
	}

	public double getAnswer() {
		return 76576500;
	}

	public double test(boolean verbose) {
	    int numberT = 1;
	    int count = 1;
		
	    while(check(numberT)<500) {
	    	//Calculate next triangle number
	    	count++;
	    	numberT = numberT + count;
	    }
	    
	    return numberT;
	}
	
	//Check how many divisors input x have
	//The method use a nice trick where we only count to sqrt(x). The reason is we now there
	//are the same number of divisors from 1->sqrt(x) and sqrt(x)->x. So we only need to calculate
	//the 1->sqrt(x) and multiply with 2.
	//
	//An example with the number 486:
	//sqrt(486) = 22
	//Divisors of 486 = 1, 2, 3, 6, 9, 18 | 27, 54, 81, 162, 243, 486
	//
	//As we can see we got the same number of divisors on both side of |
	private int check(int x)
    {
		int divCount = 0;
		int countTo = (int) Math.sqrt((double) x);
		
        for(int j = 1; j <= countTo; j++)
        {
            if(x%j == 0)
                divCount++;
        }
        
        return 2*divCount;
    }
	
}
